数据：
数据形式：
[人名]，[ID]，[操作]，[票数]，[座位类型]，"ticket of "，[车次名]，"from"，[起点]，"to"，[终点]，"in"，[日期]
    人名：中文
    ID：字符串（数字），e.g. 067117193
    操作包含：bought，refunded
    票数：数字
    座位类型：整数
    车次名：字符串，e.g. D2337
    起点／终点：中文
    日期：year-month-day，e.g. 2017-4-16

车次形式：
    D5911/D5914
    站名	    日期	        到达时间	停车时间	里程	    二等座	一等座	无座
    利川	    2017-03-28	起点站	14:38	0km 	-	    -	    -
    恩施	    2017-03-28	15:10	15:17	61km	￥18 	￥21.5	￥18
    建始	    2017-03-28	15:39	15:41	96km	￥28 	￥33.5	￥28
    宜昌东	2017-03-28	17:08	17:13	275km	￥81 	￥97 	￥81
    枝江北	2017-03-28	17:31	17:33	319km	￥93.5	￥112	￥93.5
    荆州  	2017-03-28	17:51	17:54	363km	￥106.5	￥128	￥106.5
    潜江	    2017-03-28	18:20	18:22	433km	￥127	￥152.5	￥127
    汉川 	2017-03-28	18:54	18:56	521km	￥153	￥183.5	￥153
    汉口 	2017-03-28	19:21	19:25	567km	￥166.5	￥199.5	￥166.5
    武汉 	2017-03-28	19:49	19:53	603km	￥176.5	￥212.5	￥176.5
    黄冈西	2017-03-28	20:18	20:20	657km	￥194.5	￥234.5	￥194.5
    黄冈 	2017-03-28	20:25	20:27	663km	￥196.5	￥236.5	￥196.5
    黄冈东	2017-03-28	20:35	终到站	668km	￥198.5	￥238.5	￥198.5

城市：


需要的功能：
杂项：
  注册账户：User & Admin

User:
  查询：[起点 & 终点]，[日期]，<座位类型>，<剩余票数>
  买票：[票数]，[座位类型]，[车次名]，[起点]，[终点]，[日期]
  退票：[票数]，[座位类型]，[车次名]，[起点]，[终点]，[日期]
  更新密码：
  查看当前账户状态：

Admin：
  查询：[起点 & 终点]，[日期]，<座位类型>，<剩余票数>
  添加路线：[各个车站名，按照顺序给出]
  添加车次：[路线，日期]
  删除路线：
  删除车次：
  删除用户：
  更新密码：
  查看账户：
  查看日志：

构架：
综述：
  主体为单例类Server，其中按照正确结构存储信息，相当于一个数据库。
     并提供必要的接口给Accounts
  对前端的接口由派生自Account的类User和Admin提供。
  对于各个火车相关的结构体／类在train_manager.h内。

train_manager
  城市：
    城市名；这座城市中的车站（指针）。
  车站：
    这座车站所在的城市（指针）；通过这座车站的线路（指针）。
  线路：
    线路的基本信息（名称等）；
    经过的站（数组）；
    从第i到第i+1站的第j种票票价（二维数组[i][j]）；
    该线路在某一日期是否有车次（bool／指针数组）（map？）；
  车次：
    所属的线路（指针）；
    日期；
    是否开售；
    从第i到第i+1站的第j中票余票（二维数组[i][j]）；
  车票：
    所属的车次（指针）；
    终点站，起点站（在线路中的位置）；
    价格；
    种类；
    （张数？）

Server：
  需要存储的信息：
  火车：路线，车站，城市；
  账户：用户，管理员；

  信息的查询／插入／删除：
  查询：
  a. map提供的基本查找
  b. 给出起点、终点城市，返回所有两者间的路线：
     1. 通过城市名称，利用cities得到起点城市的具体内容，
        即可以获得这座城市中的车站。
        复杂度：O(logN)；实现：map；其中N为城市个数。
     2. 枚举起点的每一座车站，可以得到它的路线；O(N)，大概有N<10；
        然后枚举经过它的每一条路线；          O(M)，大概有M<50；
          # 如果有日期，则可以跳过部分线路。
        枚举路线上的每一个车站；             O(K)，大概有K<50；
        车站中记录了这座车站所在的城市，
        直接检查是否是终点城市即可。
     3. 备注
        1) 总的时间复杂度大约为N*M*K < 25000
        2) 返回路线后，可以进行进一步的操作，买票／退票等。
        3) 实现：
           3.1) 查找城市（map提供）
           3.2) 枚举车站等（循环）（如有必要可以写两个函数）

  修改：
  a. 添加路线
  b. 添加车次
  c. 添加账户
  d. 删除车次（检查是否存在改车次）
  e.

Account:
  需要存储的信息：基本信息

  User：
  需要额外存储的信息：当前买的票
  操作：
  a. 查询：可直接调用server接口
  b. 买票：
     1. 这一步应该是在查询之后进行的，所以应当认为已经有了
        车次的指针。
     2. 实现步骤：
        2.1) 生成一张票并添加User的记录中。
        2.2) 修改车次中的余票信息。
  c. 退票（同上）：应当认为已经有了指向车票的指针。

  Admin：

字符串格式：
登录：
1. ""

查询
1. "Query"
2. "City"/"Station","名名字" * 2
3. "日期"(2017.5.6)

买票：
0. "User"
1. "Buy"
2. ""


函数实现进度：Y代表实现，YY代表实现并阅读，YYY表示debug过，YYYY表示确保没问题

query_city_city        Y
add_line               Y
add_train
buy_ticket             Y
return_ticket          Y
current_ticket         Y
login_user             Y
login_admin            Y

用户：账户余额？

正在做：
添加city etc.